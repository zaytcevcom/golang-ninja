package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func main() {
	if len(os.Args) != 4 {
		log.Fatalf("invalid args count: %d", len(os.Args)-1)
	}

	pkg, types, out := os.Args[1], strings.Split(os.Args[2], ","), os.Args[3]
	if err := run(pkg, types, out); err != nil {
		log.Fatal(err)
	}

	p, _ := os.Getwd()
	_, _ = fmt.Fprintf(os.Stdout, "%v generated\n", filepath.Join(p, out))
}

func run(pkg string, types []string, outFile string) error {
	if pkg == "" {
		return errors.New("pkg is empty")
	}
	if len(types) == 0 {
		return errors.New("no types to generate")
	}

	// normalize & deduplicate
	seen := make(map[string]struct{}, len(types))
	uniq := make([]string, 0, len(types))
	for _, t := range types {
		t = strings.TrimSpace(t)
		if t == "" {
			continue
		}
		if !isIdent(t) {
			return fmt.Errorf("invalid Go identifier: %q", t)
		}
		if _, ok := seen[t]; ok {
			continue
		}
		seen[t] = struct{}{}
		uniq = append(uniq, t)
	}
	if len(uniq) == 0 {
		return errors.New("no valid types to generate")
	}
	sort.Strings(uniq)

	var buf bytes.Buffer

	// header
	_, _ = fmt.Fprintln(&buf, "// Code generated by cmd/gen-types; DO NOT EDIT.")
	_, _ = fmt.Fprintln(&buf)
	_, _ = fmt.Fprintf(&buf, "package %s\n\n", pkg)

	// imports for generated file
	_, _ = buf.WriteString(`import (
	"database/sql/driver"
	"errors"
	"fmt"
	"github.com/google/uuid"
)

`)

	// generic helpers once per file
	_, _ = buf.WriteString(`// uuidLike â€” all generated types use [16]byte (uuid.UUID) as the underlying type.
type uuidLike interface{ ~[16]byte }

// Parse[T] parses a UUID string into a specific ID type.
func Parse[T uuidLike](s string) (T, error) {
   var zero T
   u, err := uuid.Parse(s)
   if err != nil {
       return zero, err
   }
   return T(u), nil
}

// MustParse[T] panics on parse error.
func MustParse[T uuidLike](s string) T {
   id, err := Parse[T](s)
   if err != nil {
       panic(err)
   }
   return id
}
` + "\n")

	// per-type code
	perTypeTmpl := `// %[1]s is a wrapper around uuid.UUID.
type %[1]s uuid.UUID

// zero value var
var %[1]sNil = %[1]s(uuid.Nil)

// constructor
func New%[1]s() %[1]s { return %[1]s(uuid.New()) }

// String()
func (id %[1]s) String() string { return uuid.UUID(id).String() }

// driver.Valuer
func (id %[1]s) Value() (driver.Value, error) { return id.String(), nil }

// sql.Scanner
func (id *%[1]s) Scan(src any) error {
	switch v := src.(type) {
	case nil:
		*id = %[1]sNil
		return nil
	case string:
		if v == "" { *id = %[1]sNil; return nil }
		u, err := uuid.Parse(v)
		if err != nil { return err }
		*id = %[1]s(u)
		return nil
	case []byte:
		if len(v) == 0 { *id = %[1]sNil; return nil }
		u, err := uuid.Parse(string(v))
		if err != nil { return err }
		*id = %[1]s(u)
		return nil
	default:
		return fmt.Errorf("cannot scan %%T into %[1]s", src)
	}
}

// encoding.TextMarshaler / Unmarshaler
func (id %[1]s) MarshalText() ([]byte, error) { return []byte(id.String()), nil }

func (id *%[1]s) UnmarshalText(b []byte) error {
	if len(b) == 0 { *id = %[1]sNil; return nil }
	u, err := uuid.ParseBytes(b)
	if err != nil { return err }
	*id = %[1]s(u)
	return nil
}

// IsZero
func (id %[1]s) IsZero() bool { return uuid.UUID(id) == uuid.Nil }

// gomock.Matcher: Matches(any) bool
func (id %[1]s) Matches(x any) bool {
	other, ok := x.(%[1]s)
	return ok && id == other
}

// entfield.Validator: Validate() error
func (id %[1]s) Validate() error {
	if id.IsZero() {
		return errors.New("%[1]s is zero")
	}
	return nil
}

`
	for _, t := range uniq {
		_, _ = fmt.Fprintf(&buf, perTypeTmpl, t)
	}

	// format and write
	src, err := format.Source(buf.Bytes())
	if err != nil {
		// if formatting fails, write raw for debugging
		src = buf.Bytes()
	}

	if err := os.MkdirAll(filepath.Dir(outFile), 0o755); err != nil {
		return err
	}
	return os.WriteFile(outFile, src, 0o600)
}

// isIdent performs a simple check that s is a valid Go identifier.
func isIdent(s string) bool {
	if s == "" {
		return false
	}
	for i, r := range s {
		if i == 0 {
			if !(r == '_' || r >= 'A' && r <= 'Z' || r >= 'a' && r <= 'z') {
				return false
			}
			continue
		}
		if !(r == '_' || r >= 'A' && r <= 'Z' || r >= 'a' && r <= 'z' || r >= '0' && r <= '9') {
			return false
		}
	}
	return true
}
