// Code generated by cmd/gen-types; DO NOT EDIT.

package types

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"github.com/google/uuid"
)

// uuidLike â€” all generated types use [16]byte (uuid.UUID) as the underlying type.
type uuidLike interface{ ~[16]byte }

// Parse[T] parses a UUID string into a specific ID type.
func Parse[T uuidLike](s string) (T, error) {
	var zero T
	u, err := uuid.Parse(s)
	if err != nil {
		return zero, err
	}
	return T(u), nil
}

// MustParse[T] panics on parse error.
func MustParse[T uuidLike](s string) T {
	id, err := Parse[T](s)
	if err != nil {
		panic(err)
	}
	return id
}

// ChatID is a wrapper around uuid.UUID.
type ChatID uuid.UUID

// zero value var
var ChatIDNil = ChatID(uuid.Nil)

// constructor
func NewChatID() ChatID { return ChatID(uuid.New()) }

// String()
func (id ChatID) String() string { return uuid.UUID(id).String() }

// driver.Valuer
func (id ChatID) Value() (driver.Value, error) { return id.String(), nil }

// sql.Scanner
func (id *ChatID) Scan(src any) error {
	switch v := src.(type) {
	case nil:
		*id = ChatIDNil
		return nil
	case string:
		if v == "" {
			*id = ChatIDNil
			return nil
		}
		u, err := uuid.Parse(v)
		if err != nil {
			return err
		}
		*id = ChatID(u)
		return nil
	case []byte:
		if len(v) == 0 {
			*id = ChatIDNil
			return nil
		}
		u, err := uuid.Parse(string(v))
		if err != nil {
			return err
		}
		*id = ChatID(u)
		return nil
	default:
		return fmt.Errorf("cannot scan %T into ChatID", src)
	}
}

// encoding.TextMarshaler / Unmarshaler
func (id ChatID) MarshalText() ([]byte, error) { return []byte(id.String()), nil }

func (id *ChatID) UnmarshalText(b []byte) error {
	if len(b) == 0 {
		*id = ChatIDNil
		return nil
	}
	u, err := uuid.ParseBytes(b)
	if err != nil {
		return err
	}
	*id = ChatID(u)
	return nil
}

// IsZero
func (id ChatID) IsZero() bool { return uuid.UUID(id) == uuid.Nil }

// gomock.Matcher: Matches(any) bool
func (id ChatID) Matches(x any) bool {
	other, ok := x.(ChatID)
	return ok && id == other
}

// entfield.Validator: Validate() error
func (id ChatID) Validate() error {
	if id.IsZero() {
		return errors.New("ChatID is zero")
	}
	return nil
}

// MessageID is a wrapper around uuid.UUID.
type MessageID uuid.UUID

// zero value var
var MessageIDNil = MessageID(uuid.Nil)

// constructor
func NewMessageID() MessageID { return MessageID(uuid.New()) }

// String()
func (id MessageID) String() string { return uuid.UUID(id).String() }

// driver.Valuer
func (id MessageID) Value() (driver.Value, error) { return id.String(), nil }

// sql.Scanner
func (id *MessageID) Scan(src any) error {
	switch v := src.(type) {
	case nil:
		*id = MessageIDNil
		return nil
	case string:
		if v == "" {
			*id = MessageIDNil
			return nil
		}
		u, err := uuid.Parse(v)
		if err != nil {
			return err
		}
		*id = MessageID(u)
		return nil
	case []byte:
		if len(v) == 0 {
			*id = MessageIDNil
			return nil
		}
		u, err := uuid.Parse(string(v))
		if err != nil {
			return err
		}
		*id = MessageID(u)
		return nil
	default:
		return fmt.Errorf("cannot scan %T into MessageID", src)
	}
}

// encoding.TextMarshaler / Unmarshaler
func (id MessageID) MarshalText() ([]byte, error) { return []byte(id.String()), nil }

func (id *MessageID) UnmarshalText(b []byte) error {
	if len(b) == 0 {
		*id = MessageIDNil
		return nil
	}
	u, err := uuid.ParseBytes(b)
	if err != nil {
		return err
	}
	*id = MessageID(u)
	return nil
}

// IsZero
func (id MessageID) IsZero() bool { return uuid.UUID(id) == uuid.Nil }

// gomock.Matcher: Matches(any) bool
func (id MessageID) Matches(x any) bool {
	other, ok := x.(MessageID)
	return ok && id == other
}

// entfield.Validator: Validate() error
func (id MessageID) Validate() error {
	if id.IsZero() {
		return errors.New("MessageID is zero")
	}
	return nil
}

// ProblemID is a wrapper around uuid.UUID.
type ProblemID uuid.UUID

// zero value var
var ProblemIDNil = ProblemID(uuid.Nil)

// constructor
func NewProblemID() ProblemID { return ProblemID(uuid.New()) }

// String()
func (id ProblemID) String() string { return uuid.UUID(id).String() }

// driver.Valuer
func (id ProblemID) Value() (driver.Value, error) { return id.String(), nil }

// sql.Scanner
func (id *ProblemID) Scan(src any) error {
	switch v := src.(type) {
	case nil:
		*id = ProblemIDNil
		return nil
	case string:
		if v == "" {
			*id = ProblemIDNil
			return nil
		}
		u, err := uuid.Parse(v)
		if err != nil {
			return err
		}
		*id = ProblemID(u)
		return nil
	case []byte:
		if len(v) == 0 {
			*id = ProblemIDNil
			return nil
		}
		u, err := uuid.Parse(string(v))
		if err != nil {
			return err
		}
		*id = ProblemID(u)
		return nil
	default:
		return fmt.Errorf("cannot scan %T into ProblemID", src)
	}
}

// encoding.TextMarshaler / Unmarshaler
func (id ProblemID) MarshalText() ([]byte, error) { return []byte(id.String()), nil }

func (id *ProblemID) UnmarshalText(b []byte) error {
	if len(b) == 0 {
		*id = ProblemIDNil
		return nil
	}
	u, err := uuid.ParseBytes(b)
	if err != nil {
		return err
	}
	*id = ProblemID(u)
	return nil
}

// IsZero
func (id ProblemID) IsZero() bool { return uuid.UUID(id) == uuid.Nil }

// gomock.Matcher: Matches(any) bool
func (id ProblemID) Matches(x any) bool {
	other, ok := x.(ProblemID)
	return ok && id == other
}

// entfield.Validator: Validate() error
func (id ProblemID) Validate() error {
	if id.IsZero() {
		return errors.New("ProblemID is zero")
	}
	return nil
}

// UserID is a wrapper around uuid.UUID.
type UserID uuid.UUID

// zero value var
var UserIDNil = UserID(uuid.Nil)

// constructor
func NewUserID() UserID { return UserID(uuid.New()) }

// String()
func (id UserID) String() string { return uuid.UUID(id).String() }

// driver.Valuer
func (id UserID) Value() (driver.Value, error) { return id.String(), nil }

// sql.Scanner
func (id *UserID) Scan(src any) error {
	switch v := src.(type) {
	case nil:
		*id = UserIDNil
		return nil
	case string:
		if v == "" {
			*id = UserIDNil
			return nil
		}
		u, err := uuid.Parse(v)
		if err != nil {
			return err
		}
		*id = UserID(u)
		return nil
	case []byte:
		if len(v) == 0 {
			*id = UserIDNil
			return nil
		}
		u, err := uuid.Parse(string(v))
		if err != nil {
			return err
		}
		*id = UserID(u)
		return nil
	default:
		return fmt.Errorf("cannot scan %T into UserID", src)
	}
}

// encoding.TextMarshaler / Unmarshaler
func (id UserID) MarshalText() ([]byte, error) { return []byte(id.String()), nil }

func (id *UserID) UnmarshalText(b []byte) error {
	if len(b) == 0 {
		*id = UserIDNil
		return nil
	}
	u, err := uuid.ParseBytes(b)
	if err != nil {
		return err
	}
	*id = UserID(u)
	return nil
}

// IsZero
func (id UserID) IsZero() bool { return uuid.UUID(id) == uuid.Nil }

// gomock.Matcher: Matches(any) bool
func (id UserID) Matches(x any) bool {
	other, ok := x.(UserID)
	return ok && id == other
}

// entfield.Validator: Validate() error
func (id UserID) Validate() error {
	if id.IsZero() {
		return errors.New("UserID is zero")
	}
	return nil
}
